import { prisma } from '../config/database';
import { logger } from '../shared/logger';
import { NotFoundError } from '../shared/errors/not-found.error';

// Type definitions for Meeting enums (to be generated by Prisma)
export type MeetingPlatform = 'ZOOM' | 'GOOGLE_MEET' | 'TEAMS' | 'WEBEX' | 'OTHER';
export type MeetingStatus = 'SCHEDULED' | 'IN_PROGRESS' | 'COMPLETED' | 'CANCELLED' | 'NO_SHOW';
export type CopilotMode = 'PASSIVE' | 'ACTIVE';

// ============================================
// TYPES & INTERFACES
// ============================================

export interface CreateMeetingDto {
    title: string;
    description?: string;
    startTime: Date;
    endTime: Date;
    timezone?: string;
    meetingPlatform?: MeetingPlatform;
    meetingUrl?: string;
    organizerId: string;
    dealId?: string;
    copilotEnabled?: boolean;
    copilotMode?: CopilotMode;
}

export interface UpdateMeetingDto {
    title?: string;
    description?: string;
    startTime?: Date;
    endTime?: Date;
    timezone?: string;
    meetingPlatform?: MeetingPlatform;
    meetingUrl?: string;
    dealId?: string | null;
    copilotEnabled?: boolean;
    copilotMode?: CopilotMode;
    status?: MeetingStatus;
    recordingUrl?: string;
    transcript?: string;
    aiSummary?: string;
    aiActionItems?: any;
    aiKeyMoments?: any;
    aiSentimentTimeline?: any;
    aiTalkRatio?: any;
    aiQuestionsAsked?: any;
    aiObjections?: any;
    aiBuyingSignals?: any;
    aiCoachingFeedback?: any;
    aiDealImpact?: string;
    aiNextSteps?: string;
}

export interface MeetingFilters {
    status?: MeetingStatus;
    organizerId?: string;
    dealId?: string;
    copilotEnabled?: boolean;
    copilotMode?: CopilotMode;
    startDateFrom?: Date;
    startDateTo?: Date;
    sortBy?: 'startTime' | 'createdAt' | 'updatedAt';
    sortOrder?: 'asc' | 'desc';
    page?: number;
    limit?: number;
}

export interface PaginatedResponse<T> {
    data: T[];
    pagination: {
        page: number;
        limit: number;
        total: number;
        totalPages: number;
    };
}

// ============================================
// CORE FUNCTIONS
// ============================================

export async function createMeeting(
    orgId: string,
    userId: string,
    data: CreateMeetingDto
) {
    // Verify organizer belongs to org
    const organizer = await prisma.user.findFirst({
        where: { id: data.organizerId, orgId },
    });

    if (!organizer) {
        throw new NotFoundError('Organizer not found');
    }

    // Verify deal if provided
    if (data.dealId) {
        const deal = await prisma.opportunity.findFirst({
            where: { id: data.dealId, orgId },
        });

        if (!deal) {
            throw new NotFoundError('Deal not found');
        }
    }

    const meeting = await prisma.meeting.create({
        data: {
            orgId,
            title: data.title,
            description: data.description,
            startTime: data.startTime,
            endTime: data.endTime,
            timezone: data.timezone,
            meetingPlatform: data.meetingPlatform,
            meetingUrl: data.meetingUrl,
            organizerId: data.organizerId,
            dealId: data.dealId,
            copilotEnabled: data.copilotEnabled ?? true,
            copilotMode: data.copilotMode ?? 'PASSIVE' as CopilotMode,
            status: 'SCHEDULED' as MeetingStatus,
        },
        include: {
            organizer: {
                select: { id: true, firstName: true, lastName: true, email: true },
            },
            deal: {
                select: { id: true, name: true, stage: true, amount: true },
            },
            organization: {
                select: { id: true, name: true },
            },
        },
    });

    logger.info('Meeting created', { meetingId: meeting.id, orgId, createdBy: userId });

    return meeting;
}

export async function getMeetingById(orgId: string, meetingId: string) {
    const meeting = await prisma.meeting.findFirst({
        where: { id: meetingId, orgId },
        include: {
            organizer: {
                select: { id: true, firstName: true, lastName: true, email: true },
            },
            deal: {
                select: { id: true, name: true, stage: true, amount: true, probability: true },
            },
            organization: {
                select: { id: true, name: true },
            },
        },
    });

    if (!meeting) {
        throw new NotFoundError('Meeting not found');
    }

    return meeting;
}

export async function getMeetings(
    orgId: string,
    filters: MeetingFilters = {}
) {
    const {
        status,
        organizerId,
        dealId,
        copilotEnabled,
        copilotMode,
        startDateFrom,
        startDateTo,
        sortBy = 'startTime',
        sortOrder = 'asc',
        page = 1,
        limit = 20,
    } = filters;

    const where: any = { orgId };

    if (status) where.status = status;
    if (organizerId) where.organizerId = organizerId;
    if (dealId) where.dealId = dealId;
    if (copilotEnabled !== undefined) where.copilotEnabled = copilotEnabled;
    if (copilotMode) where.copilotMode = copilotMode;
    if (startDateFrom || startDateTo) {
        where.startTime = {};
        if (startDateFrom) where.startTime.gte = startDateFrom;
        if (startDateTo) where.startTime.lte = startDateTo;
    }

    const [meetings, total] = await Promise.all([
        prisma.meeting.findMany({
            where,
            include: {
                organizer: {
                    select: { id: true, firstName: true, lastName: true, email: true },
                },
                deal: {
                    select: { id: true, name: true, stage: true, amount: true },
                },
            },
            orderBy: { [sortBy]: sortOrder },
            skip: (page - 1) * limit,
            take: limit,
        }),
        prisma.meeting.count({ where }),
    ]);

    return {
        data: meetings,
        pagination: {
            page,
            limit,
            total,
            totalPages: Math.ceil(total / limit),
        },
    };
}

export async function updateMeeting(
    orgId: string,
    userId: string,
    meetingId: string,
    data: UpdateMeetingDto
) {
    const meeting = await prisma.meeting.findFirst({
        where: { id: meetingId, orgId },
    });

    if (!meeting) {
        throw new NotFoundError('Meeting not found');
    }

    // If updating dealId, verify the deal exists
    if (data.dealId !== undefined) {
        if (data.dealId) {
            const deal = await prisma.opportunity.findFirst({
                where: { id: data.dealId, orgId },
            });
            if (!deal) {
                throw new NotFoundError('Deal not found');
            }
        }
    }

    const updated = await prisma.meeting.update({
        where: { id: meetingId },
        data: {
            ...data,
            // If status is being set to COMPLETED, set executedAt
            ...(data.status === 'COMPLETED' && { executedAt: new Date() }),
        },
        include: {
            organizer: {
                select: { id: true, firstName: true, lastName: true, email: true },
            },
            deal: {
                select: { id: true, name: true, stage: true, amount: true },
            },
        },
    });

    logger.info('Meeting updated', { meetingId, orgId, userId });

    return updated;
}

export async function deleteMeeting(orgId: string, meetingId: string) {
    const meeting = await prisma.meeting.findFirst({
        where: { id: meetingId, orgId },
    });

    if (!meeting) {
        throw new NotFoundError('Meeting not found');
    }

    await prisma.meeting.delete({
        where: { id: meetingId },
    });

    logger.info('Meeting deleted', { meetingId, orgId });

    return { success: true };
}

// ============================================
// AI COPILOT FUNCTIONS
// ============================================

export async function getMeetingAIAnalysis(orgId: string, meetingId: string) {
    const meeting = await prisma.meeting.findFirst({
        where: { id: meetingId, orgId },
        select: {
            id: true,
            title: true,
            aiSummary: true,
            aiActionItems: true,
            aiKeyMoments: true,
            aiSentimentTimeline: true,
            aiTalkRatio: true,
            aiQuestionsAsked: true,
            aiObjections: true,
            aiBuyingSignals: true,
            aiCoachingFeedback: true,
            aiDealImpact: true,
            aiNextSteps: true,
            transcript: true,
        },
    });

    if (!meeting) {
        throw new NotFoundError('Meeting not found');
    }

    return meeting;
}

export async function updateMeetingAIAnalysis(
    orgId: string,
    meetingId: string,
    analysis: {
        aiSummary?: string;
        aiActionItems?: any;
        aiKeyMoments?: any;
        aiSentimentTimeline?: any;
        aiTalkRatio?: any;
        aiQuestionsAsked?: any;
        aiObjections?: any;
        aiBuyingSignals?: any;
        aiCoachingFeedback?: any;
        aiDealImpact?: string;
        aiNextSteps?: string;
        transcript?: string;
    }
) {
    const meeting = await prisma.meeting.findFirst({
        where: { id: meetingId, orgId },
    });

    if (!meeting) {
        throw new NotFoundError('Meeting not found');
    }

    const updated = await prisma.meeting.update({
        where: { id: meetingId },
        data: analysis,
    });

    logger.info('Meeting AI analysis updated', { meetingId, orgId });

    return updated;
}

// ============================================
// UPCOMING MEETINGS
// ============================================

export async function getUpcomingMeetings(orgId: string, userId: string, days: number = 7) {
    const now = new Date();
    const futureDate = new Date();
    futureDate.setDate(futureDate.getDate() + days);

    const meetings = await prisma.meeting.findMany({
        where: {
            orgId,
            organizerId: userId,
            status: 'SCHEDULED',
            startTime: {
                gte: now,
                lte: futureDate,
            },
        },
        include: {
            deal: {
                select: { id: true, name: true, amount: true, stage: true },
            },
        },
        orderBy: { startTime: 'asc' },
    });

    return meetings;
}

// ============================================
// MEETING STATISTICS
// ============================================

export async function getMeetingStatistics(orgId: string, startDate?: Date, endDate?: Date) {
    const where: any = { orgId };

    if (startDate || endDate) {
        where.createdAt = {};
        if (startDate) where.createdAt.gte = startDate;
        if (endDate) where.createdAt.lte = endDate;
    }

    const [
        totalMeetings,
        completedMeetings,
        scheduledMeetings,
        cancelledMeetings,
        withCopilot,
    ] = await Promise.all([
        prisma.meeting.count({ where }),
        prisma.meeting.count({ where: { ...where, status: 'COMPLETED' } }),
        prisma.meeting.count({ where: { ...where, status: 'SCHEDULED' } }),
        prisma.meeting.count({ where: { ...where, status: 'CANCELLED' } }),
        prisma.meeting.count({ where: { ...where, copilotEnabled: true } }),
    ]);

    return {
        total: totalMeetings,
        completed: completedMeetings,
        scheduled: scheduledMeetings,
        cancelled: cancelledMeetings,
        withCopilot,
        completionRate: totalMeetings > 0 ? (completedMeetings / totalMeetings) * 100 : 0,
        copilotAdoptionRate: totalMeetings > 0 ? (withCopilot / totalMeetings) * 100 : 0,
    };
}
